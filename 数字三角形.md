---
title: 数字三角形(线性dp)
date: 2020-01-28 12:03:50
tags:
    - dp
categories: 算法
---
# ALGO_124 算法训练 数字三角形
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。
```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
``` 
<!-- more -->

## 输入格式

第一行包含整数n，表示数字三角形的层数。  
接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

## 输出格式
输出一个整数，表示最大的路径数字和。

## 数据范围
1≤n≤100,
0≤三角形中的整数≤99
## 输入样例：
```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```
## 输出样例：
```
30
```
## 题解
**算法：**
线性dp

遇到dp的题就首先思考状态转移方程这个很好想到  
每一个点的权值就是其上方和左上方的最大权值再加上其自身的权值，然后dp每一个点的值再找出最后一行的最大值就是答案

**状态转移方程：**
``` c++
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + v[i][j];
```


## AC代码
``` c++
#include<bits/stdc++.h>
using namespace std;

int dp[105][105],v[105][105];
const int INF = 0x3f3f3f3f;

int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            cin>>v[i][j];
        }
    }

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + v[i][j];
        }
    }

    int ans = -INF;
    for (int i = 1; i <= n; i++)
    {
        ans = max(ans, dp[n][i]);
    }
    cout << ans << endl;
    return 0;
}
```
## 注意
要从第一列开始，第0列要空出来，因为如果从第0列开始的话当i=0的时候dp[i-1][j]会**越界**
